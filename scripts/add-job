#!/usr/bin/env python3
"""
Script to autogenerate the files necessary to add a new
job to the project.
"""

import json
import logging
import os
import sys
import pathlib
from string import Template
from textwrap import dedent

SCRIPT_DIR = pathlib.Path(__file__).parent.resolve()

def generate_harness_files(directory, component, job, target):
    file_contents = f"""\
# This file has been generated by the add_job script
add_library({job}_harness STATIC
  {job}_harness.c)
target_include_directories({job}_harness
  PRIVATE ${{MBEDTLS_DIR}}/include/
  ${{MBEDTLS_DIR}}/library/
  ${{PROJECT_SOURCE_DIR}}/seahorn/include/
  ${{SEAMOCK_ROOT}}/include)
sea_link_libraries({job}_harness ssl_msg.opt.ir)
sea_link_libraries({job}_harness seahorn_mbedtls_util_lib.ir)
sea_overlink_libraries({job}_harness {job}_env.ir)
sea_attach_bc({job}_harness)
sea_add_unsat_test({job}_harness)
    """
    unit_proof_dir = directory.joinpath('unit_proof')
    unit_proof_dir.mkdir()
    with unit_proof_dir.joinpath('CMakeLists.txt').open(mode='w') as file:
      file.write(file_contents)
    # now add a c file
    file_path = unit_proof_dir.joinpath('{}_harness.c'.format(job))
    file_path.touch()

def generate_lib_files(directory, job):
    file_contents = f"""\
# This file has been generated by the add_job script
add_library(ssl_msg STATIC
  ${{MBEDTLS_DIR}}/library/ssl_msg.c)
target_include_directories(ssl_msg
  PRIVATE ${{MBEDTLS_DIR}}/include/
  ${{MBEDTLS_DIR}}/library/
  ${{PROJECT_SOURCE_DIR}}/seahorn/include/
  ${{SEAMOCK_ROOT}}/include)
sea_attach_bc(ssl_msg)
set(LLVMIR_OPT ${{SEA_PP}})
llvmir_attach_opt_pass_target(TARGET ssl_msg.opt.ir DEPENDS ssl_msg.ir
  "--externalize-function=^ssl_*" "-externalize-functions-delete=false" "--externalize-fns")
    """
    lib_dir = directory.joinpath('lib')
    lib_dir.mkdir()
    with lib_dir.joinpath('CMakeLists.txt').open(mode='w') as file:
      file.write(file_contents)

def generate_env_files(directory, job):
    file_contents = f"""\
# This file has been generated by the add_job script
add_library({job}_env STATIC {job}_env.cc)
target_include_directories({job}_env
  PRIVATE ${{MBEDTLS_DIR}}/include/
  ${{MBEDTLS_DIR}}/library/
  ${{PROJECT_SOURCE_DIR}}/seahorn/include/
  ${{SEAMOCK_ROOT}}/include)
sea_attach_bc_cc({job}_env)
    """
    env_dir = directory.joinpath('env')
    env_dir.mkdir()
    with env_dir.joinpath('CMakeLists.txt').open(mode='w') as file:
      file.write(file_contents)
    # now add a cc (C++ for seamock) file
    file_path = env_dir.joinpath('{}_env.cc'.format(job))
    file_path.touch()

def add_subdir_to_cmake(directory, subdir):
    file_contents = Template(dedent("""\
        add_subdirectory($subdir)
    """)).substitute(subdir=str(subdir))
    f = os.path.join(directory, 'CMakeLists.txt')
    with open(f, 'a') as file:
        file.write(file_contents)

# create new component e.g. library if needed and update associated cmake file
# directory is job directory
def create_or_update_component(directory):
    p = directory.parents[0]
    if p.exists() and not p.is_dir():
      logging.error('{} exists and is not a directory!'.format(directory))
      sys.exit(1)
    elif not p.exists():
      p.mkdir()
      p.touch('CMakeLists.txt')
      # go up to seahorn
      seahorn_dir = p.parents[1]
      add_subdir_to_cmake(seahorn_dir, directory.relative_to(seahorn_dir))  # new dir so update seahorn dir cmake file
    add_subdir_to_cmake(p, directory.relative_to(p)) # update component cmake file


def create_directory(directory):
  assert not directory.exists()
  directory.mkdir()
  env_dir = directory / 'env'
  add_subdir_to_cmake(directory, env_dir.relative_to(directory))
  # lib_dir = directory / 'lib'
  # add_subdir_to_cmake(directory, lib_dir.relative_to(directory))
  unit_proof_dir = directory / 'unit_proof'
  add_subdir_to_cmake(directory, unit_proof_dir.relative_to(directory))

def ask_yes_no_question(question):
    while True:
        user_input = input(question + " (yes/no): ").strip().lower()
        if user_input == "yes" or user_input == "y":
            return True
        elif user_input == "no" or user_input == "n":
            return False
        else:
            print("Please enter 'yes' or 'no'.")

def main():
  if len(sys.argv) != 4:
    print("Usage: add_job <component> <job> <SUT>")
    print("Please provide three arguments.")
    print("<component> The component of the job. E.g., library")
    print("<job> The name of the job. E.g., ssl_msg_close_notify")
    print("<SUT> The system under test. E.g., ssl_msg.c")
    sys.exit(1)

  component = sys.argv[1]
  job = sys.argv[2]
  sut = sys.argv[3]

  directory = SCRIPT_DIR.parent / 'seahorn' / 'jobs' / component / job
  ans = ask_yes_no_question('I will create the following directory: {}'.format(str(directory)))
  if not ans:
    logging.error('Doing nothing. Exiting!')
    sys.exit(1)

  create_or_update_component(directory)
  create_directory(directory)
  generate_harness_files(directory, component, job, sut)
  # generate_lib_files(directory, job)
  generate_env_files(directory, job)
  print(f"Created job: {job}")

if __name__ == "__main__":
    main()
